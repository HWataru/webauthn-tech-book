= WebAuthn

== 概要

//image[webauthn_overview][FIDO2 Overview]

@<img>{webauthn_overview} は Web Authentication API（以下WebAuthn） と Platform および、
External Authenticator の関係図です。

前章で解説したとおり、FIDO2.0 は WebAuthn と、 CTAP1/CTAP2 および Platform API を、
それぞれの OS,Browser ベンダーが実装して実現するプロジェクトです。
この図を見れば解るとおり、WebAuthn の裏側には、 Platform API や CTAP が存在することがわかります。

Platform API は、Platform、つまり PC や スマートフォンに登載された TPM や TEE といったセキュアチップと通信を行います。
PIN あるいはデバイスに登載された生体認証デバイスによって、セキュアチップ上での秘密鍵の生成や保存のための認証が行われます。
この API が利用できるかどうかは isUserVerifyingPlatformAuthenticatorAvailable() というメソッドが用意されており、
ネイティブアプリケーション、あるいは Web ブラウザーから呼び出せるようになっています。

== CTAP

CTAP とは Client to Authenticator Protocol@<fn>{CTAP} の略で、Client が roaming Authenticator と通信するための仕様です。

CTAP には CTAP1 と CTAP2 が存在し、CTAP1 は U2F プロトコルを指します。
一方 CTAP2 は CTAP1 を拡張した規格です。CTAP2 では CTAP1 では実現できなかったパスワードレス認証や、PIN や 生体認証を利用したマルチファクター認証がスペックとして追加されています。

//footnote[CTAP][Client To Authenticator Protocol: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-client-to-authenticator-protocol-v2.0-id-20180227.html]



====[column] U2F と CTAP1

WebAuthn では U2Fプロトコルに対応した Authenticator を利用することが可能です。
少し説明が難しいのですが、その場合 CTAP1、つまり U2Fプロトコルとは一部パラメータ等が異なります。
具体的には U2F では AppID、WebAuthn では RP ID と呼ばれているパラメータが異なっており、、前者がプロトコル名 (https://) を含むのに対し、後者は origin 名しか含みません。
そのため、現在 U2F で認証をしているサービスをそのまま、WebAuthn に切り替えることはできません。
ただし、WebAuthn のスペックには、この差を埋めるための Extension（AppIdExtention） が定義されており、
U2Fの認証サービスから WebAuthn への切り替えをスムーズにするための工夫がされています。

== Web Authentication API

Web Authentication API は W3C で策定が進められている API で、ウェブブラウザ上に実装されています。
このAPIですが、実は Credential Management API @<fn>{CDM} という認証情報を管理する API を拡張する形で実装されています。

Credential Management API にはたった2つのメソッドが定義されています。
資格情報を作成する credentials.create() および、取得する credentials.get() です。
WebAuthn ではこの2つのメソッドに、公開鍵を利用した資格情報を作成するためのオプションである、
PublicKeyCredentialCreationOptions や PublicKeyCredentialRequestOptions を指定して、Credential を作成します。

//listnum[PublicKeycredential][2つのメソッドと、2つのオプション][js]{

navigator.credentials.create({publicKey: PublicKeyCredentialCreationOptions})

navigator.credentials.get({publicKey: PublicKeyCredentialRequestOptions})

//}


通常これらのオプションは、サービス提供者のポリシーや、ユーザーの選択によってパラメーターを変更することになります。
ただしオプションに関しては数も非常に多く、複雑であるため、本書では基本的な流れをとらえてるためシンプルなオプションで解説をすすめたいと思います。

//footnote[CDM][Credential Management API : @<href>{https://www.w3.org/TR/credential-management-1/}]

=== Create a New Credential

@<img>{WebAuthn_Registration_r4} は MDN Web docs に記載されている WebAuthn の登録フローです。

//image[WebAuthn_Registration_r4][Registration* https://developer.mozilla.org/ja/docs/Web/API/Web_Authentication_API]

Credential Management API のメソッドである navigator.credentials.create() の引数である、CredentialCreationOptions 
として、{ publicKey: options } といった形で WebAuthn で利用するオプションを渡しています。
これらのオプションは  PublicKeyCredentialCreationOptions とよばれ、
「誰に対して」「どのような Authenticator」を利用して「どのRPの」認証情報を作成するか、といったことを定めます。

もっともシンプルな例として @<list>{webauthnAPI} を見てみましょう。

//listnum[webauthnAPI][Web Authentication][js]{

navigator.credentials.create({
    publicKey: {
        challenge: new Uint8Array([21,31,105 /* 29 more random bytes generated by the server */]),

        rp: {
            id: "example.com" //省略可能
            name: "ACME Corporation"
        },

        user: {
            id: Uint8Array.from(window.atob("MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII="), c=>c.charCodeAt(0)),
			displayName: "watahani",
        },

        pubKeyCredParams: [
            {
                type: "public-key",
                alg: -7 // "ES256" IANA COSE Algorithms registry
            },
            {
                type: "public-key",
                alg: -257 // Value registered by this specification for "RS256"
            }
        ]
    }
})

//}

@<list>{webauthnAPI} は必須のオプションのみ指定しました。
@<strong>{challenge} は rpサーバーから送られるランダムなバイト列です。この例では、説明のため js 上で生成していますが、
他のパラメータ含め、通常サーバー側から送られることに注意してください。

@<strong>{rp} は認証先のRPに関するパラメーターで、@<strong>{name} は必須のパラメーターです。
@<strong>{id} は省略可能なパラメーターで、省略した場合は現在アクセスしている origin と同一の値になります。
また、@<strong>{rp.id} を直接指定することも可能で、 subdomain.example.comというドメインで利用する
@<strong>{rp.id} としてexample.com を指定することが可能です。
そうしたばあい、 *.example.com で使いまわすことが可能な認証情報を作成することが可能です。

@<strong>{user} は認証情報を利用するユーザーに関するパラメーターです。
@<strong>{displayName} は、@<strong>{rp.name} と合わせて、ユーザーへの同意画面で利用されたり、
Authenticator 上で、アカウント情報を表示する際などに利用されます。
@<strong>{user.id} はサービス固有の ID で利用者に対して表示することはありませんが必ずユニークな id である必要があります。
一般的にはサービスの内部で利用しているユーザーのユニークidを利用することになるでしょう。

=== PublicKeyCredential

navigator.credentials.create() メソッドで公開鍵暗号ベースの Credential を作成しようとすると、Authenticator へこれらの情報が送られます。
Authenticator は Credential を作成するためにユーザー認証を行います。
たとえば Authenticator のボタンをタップする、あるいは生体認証によるユーザー認証を行うといった動作になります。

ユーザー認証が完了すると Authenticator は作成した Credentail を Client に返します。
WebAuthn では PublicKeyCredential とよばれ、@<list>{PublicKeyCredential} のような形となります。

//listnum[PublicKeyCredential][PublicKeyCredential]{
    rawId: [ArrayBuffer] (32 bytes)
        3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
        C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
    id: [ArrayBuffer] (32 bytes)
        3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
        C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
    response: {
        clientDataJSON: [ArrayBuffer],
        attestationObject: [ArrayBuffer],
    },
    getClientExtensionResults: () => (result: AuthenticationExtensionsClientOutputs)
}
//}

id は、@<strong>{CredentialId} と呼ばれ生成された PublicKeycredential を一意に定めるIDです。
@<strong>{clientDataJSON} は、Client（ブラウザー）で生成された @<strong>{challenge} を含むデータで、origin の検証、Attestationの検証に利用されます。

@<strong>{AttestationObject} は、いくつかの重要な情報を含んでいますが、ここでは Authenticator で生成された公開鍵を含むとだけにとどめておきます。

サーバーへのレスポンスは CredentailId, clientDataJSON, attestationObject（に含まれる公開鍵）が送られ、登録ユーザーに紐づけて保存されます。


=== Use an Existing Credential to Make an Assertion

作成された PublicKeycredential はサーバーに送られ次回以降の認証で利用されます。
一方 Authenticator も CredentialId と PublicKeycredential の組み合わせを記憶しており、次回の認証時に CredentailId を直接指定することも可能で、
サーバーに送った公開鍵に対応する秘密鍵を取り出すことが可能になっています。

認証の際は navigator.credentials.get() に {publicKey: PublicKeyCredentialRequestOptions} といった形のオプションを指定し、既存の PublicKeyCredential を取得します。
@<list>{create} は先ほど生成した、 3C B4 0D 54... という CredentailId で指定する PublicKeycredential を利用して認証をするというリクエストです。

//listnum[create][navigator.credentials.get()][js]{

navigator.credentials.get({
    publicKey: {
        challenge: new Uint8Array([21,31,105 /* 29 more random bytes generated by the server */]),
        allowCredentials: [
        {
            id: [ArrayBuffer] (32 bytes)
                3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
                C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
            type: "public-key",
        },
    ],
    }
})

//}

@<strong>{challenge} は先ほどと同様にサーバーから送られるランダムなバイト配列です。
今回は id(3C B4 0D...) に対応する PublicKeycredential で、Challenge に署名をして返します。


== まとめ

    1. Web Authentication API は 公開鍵暗号を利用したチャレンジレスポンス認証
    1. Web Authentication API は Credential Management API の拡張として定義
    1. API は credentials.create() と credentials.get() のふたつの認証API

== サンプル

かく

