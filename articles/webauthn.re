= WebAuthn

== 概要

//image[webauthn_overview][FIDO2 Overview]

@<img>{webauthn_overview} は Web Authentication API（以下WebAuthn） と Platform および、
External Authenticator の関係図です。

前章で解説したとおり、FIDO2.0 は WebAuthn と、 CTAP1/CTAP2 および Platform API を、
それぞれの OS,Browser ベンダーが実装して実現するプロジェクトです。
この図を見れば解るとおり、WebAuthn の裏側には、 Platform API や CTAP が存在することがわかります。

Platform API は、Platform、つまり PC や スマートフォンに登載された TPM や TEE といったセキュアチップと通信を行います。
PIN あるいはデバイスに登載された生体認証デバイスによって、セキュアチップ上での秘密鍵の生成や保存のための認証が行われます。
この API が利用できるかどうかは isUserVerifyingPlatformAuthenticatorAvailable() というメソッドが用意されており、
ネイティブアプリケーション、あるいは Web ブラウザーから呼び出せるようになっています。

== CTAP

CTAP とは Client to Authenticator Protocol@<fn>{CTAP} の略で、Client が roaming Authenticator と通信するための仕様です。

CTAP には CTAP1 と CTAP2 が存在し、CTAP1 は U2F プロトコルを指します。
一方 CTAP2 は CTAP1 を拡張した規格です。CTAP2 では CTAP1 では実現できなかったパスワードレス認証や、PIN や 生体認証を利用したマルチファクター認証がスペックとして追加されています。

//footnote[CTAP][Client To Authenticator Protocol: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-client-to-authenticator-protocol-v2.0-id-20180227.html]



====[column] U2F と CTAP1

WebAuthn では U2Fプロトコルに対応した Authenticator を利用することが可能です。
少し説明が難しいのですが、その場合 CTAP1、つまり U2Fプロトコルとは一部パラメータ等が異なります。
具体的には U2F では AppID、WebAuthn では RP ID と呼ばれているパラメータが異なっており、、前者がプロトコル名 (https://) を含むのに対し、後者は ドメイン名しか含みません。
そのため、現在 U2F で認証をしているサービスをそのまま、WebAuthn に切り替えることはできません。
ただし、WebAuthn のスペックには、この差を埋めるための Extension（AppIdExtention） が定義されており、
U2Fの認証サービスから WebAuthn への切り替えをスムーズにするための工夫がされています。

== Web Authentication API

Web Authentication API は W3C で策定が進められている API で、ウェブブラウザ上に実装されています。
このAPIですが、実は Credential Management API @<fn>{CDM} という認証情報を管理する API を拡張する形で実装されています。

Credential Management API にはたった2つのメソッドが定義されています。
資格情報を作成する credentials.create() および、取得する credentials.get() です。
WebAuthn ではこの2つのメソッドに、公開鍵を利用した資格情報を作成するためのオプションである、
PublicKeyCredentialCreationOptions や PublicKeyCredentialRequestOptions を指定して、Credential を作成します。

//listnum[PublicKeycredential][2つのメソッドと、2つのオプション][js]{

navigator.credentials.create({publicKey: PublicKeyCredentialCreationOptions})

navigator.credentials.get({publicKey: PublicKeyCredentialRequestOptions})

//}


通常これらのオプションは、サービス提供者のポリシーや、ユーザーの選択によってパラメーターを変更することになります。
ただしオプションに関しては数も非常に多く、複雑であるため、本書では基本的な流れをとらえてるためシンプルなオプションで解説をすすめたいと思います。

//footnote[CDM][Credential Management API : @<href>{https://www.w3.org/TR/credential-management-1/}]

=== Create a New Credential

@<img>{WebAuthn_Registration_r4} は MDN Web docs に記載されている WebAuthn の登録フローです。

//image[WebAuthn_Registration_r4][Registration* https://developer.mozilla.org/ja/docs/Web/API/Web_Authentication_API]

Credential Management API のメソッドである navigator.credentials.create() の引数である、CredentialCreationOptions 
として、{ publicKey: options } といった形で WebAuthn で利用するオプションを渡しています。
これらのオプションは  PublicKeyCredentialCreationOptions とよばれ、
「誰に対して」「どのような Authenticator」を利用して「どのRPの」認証情報を作成するか、といったことを定めます。

もっともシンプルな例として @<list>{create} を見てみましょう。

//listnum[create][navigator.credentails.create()][js]{

navigator.credentials.create({
    publicKey: {
        challenge: new Uint8Array(
          [21,31,105 /* 29 more random bytes generated by the server */]
        ),

        rp: {
            id: "example.com" //省略可能
            name: "ACME Corporation"
        },

        user: {
            id: Uint8Array.from(
              window.atob("MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII="), 
              c=>c.charCodeAt(0)
            ),
			displayName: "watahani",
        },

        pubKeyCredParams: [
            {
                type: "public-key",
                alg: -7 // "ES256" IANA COSE Algorithms registry
            },
            {
                type: "public-key",
                alg: -257 // Value registered by this specification for "RS256"
            }
        ]
    }
})

//}

@<list>{webauthnAPI} は必須のオプションのみ指定しました。
@<strong>{challenge} は rpサーバーから送られるランダムなバイト列です。この例では、説明のため js 上で生成していますが、
他のパラメータ含め、通常サーバー側から送られることに注意してください。

@<strong>{rp} は認証先のRPに関するパラメーターで、@<strong>{name} は必須のパラメーターです。
@<strong>{id} は省略可能なパラメーターで、省略した場合は現在アクセスしている origin のドメイン名と同一の値になります。
また、@<strong>{rp.id} を直接指定することも可能です。
例えば subdomain.example.com 上で、rp.id を指定しない場合、暗黙的に rp.id は subdomain.example.com になります。
しかし、subdomain.example.com 上では、@<strong>{rp.id} としてexample.com を指定することも可能です。
そうしたばあい、 *.example.com で使いまわすことが可能な認証情報を作成することが可能です。

@<strong>{user} は認証情報を利用するユーザーに関するパラメーターです。
@<strong>{displayName} は、@<strong>{rp.name} と合わせて、ユーザーへの同意画面で利用されたり、
Authenticator 上で、アカウント情報を表示する際などに利用されます。
@<strong>{user.id} はサービス固有の ID で利用者に対して表示することはありませんが必ずユニークな id である必要があります。
一般的にはサービスの内部で利用しているユーザーのユニークidを利用することになるでしょう。

=== PublicKeyCredential --credentails.create({pulbickey})--

navigator.credentials.create() メソッドで公開鍵暗号ベースの Credential を作成しようとすると、Authenticator へこれらの情報が送られます。
Authenticator は Credential を作成するためにユーザー認証を行います。
たとえば Authenticator のボタンをタップする、あるいは生体認証によるユーザー認証を行うといった動作になります。

ユーザー認証が完了すると Authenticator は作成した Credentail を Client に返します。
レスポンスは、PublicKeyCredential として navigator.credentials.create() の返す Promise オブジェクトの戻り値として返されます。
PublicKeyCredential は@<list>{PublicKeyCredential} のような形となります。

//listnum[PublicKeyCredential][PublicKeyCredential]{
    rawId: [ArrayBuffer] (32 bytes)
        3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
        C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
    id: [ArrayBuffer] (32 bytes)
        3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
        C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
    response: {
        clientDataJSON: [ArrayBuffer],
        attestationObject: [ArrayBuffer],
    },
    getClientExtensionResults: () => {
      return authenticationExtensionsClientOutputs;
    }
}
//}

id は、@<strong>{CredentialId} と呼ばれ生成された PublicKeycredential を一意に定めるIDです。
@<strong>{response} は @<strong>{AuthenticatorAttestationResponse} と呼ばれ、 clientDataJSON および AttestationObject を含むオブジェクトです。 
@<strong>{clientDataJSON} は、Client（ブラウザー）で生成された @<strong>{challenge} を含むデータで、実際には JSON を Base64 エンコードしたバイト配列です。
origin の検証、Attestationの検証に利用されます。

//listnum[clientDataJSON][clientDataJSON type は webauthn.create もしくは webauthn.get]{
{
    "type" : "webauthn.create",
    "challenge" : "OVtTIlKnwUaR-MsMYiD6D8g0zqntXIe-g2hs...",
    "origin" : "https://example.com",
    "tokenBinding" : {"status" : "supported"}
}
//}

@<strong>{AttestationObject} は、いくつかの重要な情報を含んでいますが、
ここでは Authenticator で生成された公開鍵と、Reply攻撃を防ぐため、署名をするたびに増える Counter を含む、とだけにとどめておきます。
サーバーへのレスポンスは CredentailId, clientDataJSON, attestationObject（に含まれる公開鍵およびCounter）が送られ、登録ユーザーに紐づけて保存されます。
詳しいサーバー側での処理は Spec 7.1. Registering a New Credential@<fn>{registering-a-new-credential} を参照ください。

//footnote[registering-a-new-credential][https://w3c.github.io/webauthn/#registering-a-new-credential]

=== Use an Existing Credential to Make an Assertion

作成された PublicKeycredential はサーバーに送られ次回以降の認証で利用されます。
一方 Authenticator も CredentialId と PublicKeycredential の組み合わせを記憶しており、次回の認証時に CredentailId を直接指定することも可能で、
サーバーに送った公開鍵に対応する秘密鍵を取り出すことが可能になっています。

認証の際は navigator.credentials.get() に {publicKey: PublicKeyCredentialRequestOptions} といった形のオプションを指定し、既存の PublicKeyCredential を取得します。
@<list>{get} は @<list>{create} で生成した、 3C B4 0D 54... という CredentailId で指定する PublicKeycredential を利用して認証をするというリクエストです。

//listnum[get][navigator.credentials.get()][js]{

navigator.credentials.get({
    publicKey: {
        challenge: new Uint8Array(
          [21,31,105 /* 29 more random bytes generated by the server */]
        ),
        allowCredentials: [
        {
            id: [ArrayBuffer] (32 bytes)
                3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
                C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
            type: "public-key",
        },
    ],
    }
})

//}

@<strong>{challenge} は先ほどと同様にサーバーから送られるランダムなバイト配列です。
今回は id(3C B4 0D...) に対応する PublicKeycredential で、Challenge に署名をして返します。

このメソッドが呼ばれると Client は接続している Authenticator を列挙し、サーバーから送られた CredentailId に対応する Authenticator を探します。
ユーザーの認証処理が完了すると、Authenticator は CredentialId に対応する PublicKeyCredential を返します。

=== PublicKeyCredential --credentails.get({pulbickey})--

ユーザーの認証処理が完了すると Authenticator は Client にレスポンスを返します。
レスポンスは、PublicKeyCredential として navigator.credentials.get() の返す Promise オブジェクトの戻り値として返されます。
認証情報を作成した際のレスポンスである @<list>{PublicKeyCredential} とは異なり、
response には AuthenticatorAssertionResponse がセットされ、publicKey などが含まれる AttestationObject は含まれておらず、
代わりに authenticatorData と signature が返されます。

//listnum[AuthenticatorAssertionResponse][AuthenticatorAssertionResponse]{
    rawId: [ArrayBuffer] (32 bytes)
        3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
        C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
    id: [ArrayBuffer] (32 bytes)
        3C B4 0D 54 85 0C 2A 39 EF 4F 9B A5 E7 5C 66 72
        C1 CB 8D 02 54 66 0A 0B 88 07 AE 09 4A 55 08 6D,
    response: {
        clientDataJSON: [ArrayBuffer],
        authenticatorData: [ArrayBuffer],
        signature: [ArrayBuffer],
        userhandle: [ArrayBuffer]
    },
    getClientExtensionResults: () => {
      return authenticationExtensionsClientOutputs;
    }
}
//}

ClientData は credentials.create() の際の @<list>{clientDataJSON}同様で、type のみ webauthn.get となっています。
authenticatorData は、さまざまなデータを含みますが、今は RP ID Hash, 1yte のFlags, Counter が含まれるものだと思ってください。

@<strong>{signature} は credentials.get() で作成した publicKey に対応する秘密鍵で作成した署名で、
authenticatordata と clientDatan の SHA256 ハッシュを計算した clientDataHash を結合したバイト配列に対して行われます。

サーバー側では ClientDataJSON に含まれる challenge, origin の検証、authenticatorData に含まれる rpId の検証、Flags の検証を行った後
保存されている publicKey で署名の検証を行います。
最後に、Counter が前回認証時よりも増えているかの検証を行い、認証を完了します。

詳しいサーバー側での処理は Spec 7.2. Verifying an Authentication Assertion@<fn>{verifying-assertion} を参照ください。

//footnote[verifying-assertion][https://w3c.github.io/webauthn/#verifying-assertion]


== まとめ

以上が webauthn の Credential の作成および、保存された Credential を用いた認証の流れです。
WebAuthn のポイントとしては次の3つが挙げられます。

    1. Web Authentication API は 公開鍵暗号を利用したチャレンジレスポンス認証
    1. Web Authentication API は Credential Management API の拡張として定義
    1. API は credentials.create() と credentials.get() のふたつの認証API

WebAuthn には今回は説明しませんでしたが、UserVerification を求めるオプションや、
Authenticator内に認証情報を保存してユーザー名を入れずにパスワードレス認証を行う仕様もあります。
